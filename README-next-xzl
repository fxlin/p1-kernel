Apr 22 2024 reorg the code source

this repo contains the kernel and a lean userspace
    kernel/     kernel source
    kernel/addon/  heavy 3rd party kernel code, e.g. usb driver
    usr/        a minimum userspace, inc apps like "slider" and "nes"
        all apps here have no dependency on libc
        libnew/     glue to libc
        libminisdl/ implemented sdl interface, depends on libc (newlib)
    old/        snapshots of kernel sources
    scripts/    utility scripts
    staged/     usable, but unused code

~~~~~~~~~~~~~~~~~~~~~~~~~
roadmap... 
exp7: 
    sync (spinlock, sleeplock) & corresponding sched support (sleep, etc.)
    more syscalls
    more vm functions. copyin, copyout

block layer, buf, vfs, filesys, disk driver (so that we can have basicaly fs tree working)
    disk driver woulnd't be necessary but it's tightly coupled with vfs at this time. 

console, uart (improved)
    b/c user now needs to call sys_write() to console. uart driver needs to support multithreading
        also irq driven

NEXT -- improved uart driver, then enable console. 

NEXT --- fixe bug. cf sysfile.c 293 V

NEXT --- deeper issues in fs. most related to fs/blk/cache/lock not init'd 
    fixed a bug in printf (long)

thought -- userspace printf() (write()) tightly coupled with vfs, fs, and block device driver. 
    need to provide an easier way to debug. 


TODO for mm: in the long run, maybe need a function for unmapping/freeing a user va 
region, the problme is that mm->user_pages are stord in an array, therefore 
unmapping/freeing will leave holes there, which complicate things. 

do we really need mm->user_pages? if we need to free them, 
    we can follow mm->pgd to find all user pages


TODO: 
enable disk driver irq (right now not gettting irq?)
inode for "/" must exists on disk... 
    (it was created in memory, but invalid, meaning not loaded from disk)
    first time the root inode gets ilocked(), it will try to read from disk ... no irq, dead.
    fix this 
FIXED 

fsinit() must be called. <---- V

------------
HOW TO BUILD DISK IMAGE... 
xl6yq@granger1 (riscv)[xv6-riscv]$ mkfs/mkfs /tmp/sd.bin README
nmeta 46 (boot, super, log blocks 30 inode blocks 13, bitmap blocks 1) blocks 1954 total 2000
balloc: first 50 blocks have been allocated
balloc: write bitmap block at sector 45

"README" is a file
-------------
V: fork() should also clone opened fd? 
V only 1 user task printing coudl be the other does not have a valid fd (always spinning then ...)

TODO: test exec() ... with standalone user app   v

call_sys_write(1 /*stdout*/, msg, strlen(msg));     // WILL FAIL. can be used for debugging 
----> use this as a test case ... to improve expcetion handling... userspace unwinding, etc. 

[x] ramdisk ... 
convert to c header; 
or use linker to include binary image (just like how we link font   and pic)
    shall we include a zip fuction?

==== THOUGHTS ====
by using ramdisk, the actual disk driver (irq driven) can come in much later. 

hence, less concurrncy issus in fs, easier to debug other parts of the OS (scheduling etc)

uart driver ... should maintaina trivial version (in addition to the full fledged one that can support console). easier to debug 
    * no spinlock, 
    * no "wakeup" 
    * no tx irq 
    can be invoked from a "debug" syscall (instead of as console dev file)... also simplify things 


[x] TODO: exec() cannot parse arguments correctly... argc always 0. fix it. 


[x] after some changes, task1 was waiting for blockio but didnt get woken up??
check: if driver's irq called wakeup() and why it is not changing task1's state
to RUNNABLE
(still WAITING)

1st standalone user program -- "echo" -- will test exec() and arg passing. 
"ls" -- will test more fs functions
"mkdir" then "ls"

[x] forktest (the basis of shell, cannot always call exec() from kernel 
and change the arguments
    for which sys_wait() must be implemented; sys_exit() also shall improve.
        ZOMBIE state....

[x] reivew code sbrk.. make p->sz p->codesz not have to be page aligned. 
sbrk: make sure no additiona pages are allocate freed...

[x] alloc_user_pages ... implement logic to "bail out" and reserve page allocation

-------------
exp9 more efficient VM impl. overhaul tcb ds for userpages (va and pa)
    dont track each page, just a range. otherwise we cannot scale to large user task

[x]  get kill() works, which reuirese to modify syacall path entry/exit kernel. 
    has to write asm

[?] -O2 exec() will fail. user.c problem. cannot control link-relative addr
    impl an assembly launcher ...   
    USE A TEMP SOLUTION --- use -O0 only for user. c

[x] improve demand paging, do_mem_abort only for user va range 
    sbrkfail passed

[x] bring up (most) standalone user programs. shell 

----> now can automate tests (important to code refactoring)

[.] refactor code, clean up, esp locking (w/ repeat tests)
    SOME IS DONE. MORE NEEDED FOR SCHED.C (locking)

-------------
[x] rpi3 hardware bring up 
    memory attribute. ldxr stxr will fail if cache not on, mem not mapped as shareable
    also., more mmu options (in sys controller) must be set otherwise el0 will have mem error
    enforce compiler to use aligned acecss -- to be consistent with mmu setup


[x] mini uart quirks
    attempted but cannot get tx irq working in a clean fashion..
        the unknown hardware features + print msgs themselves will interfere with 
        tx == the problem becomes quite messy 

        lesson is: need a simple, reliable way to debug (tx without causing new
        irq), or at least the hw is known how to work. no surprises. 

        solution: turnin goff uart tx irq. write (to console) to kernel --> 
        wait until uart tx becomes idle, then start to tx
-------------

[x] add ramdisk support

[x] mbox suppoort (prerequiwsit for usb, display.. a bunch of things)
    after l2 cache is on, cpu/gpu cache no longer coherent. hence either needs
    cpuside's uncached mapping (slow, "dma pool"?) or explicit cache flush/invalidate
    [x] add cache flush/invalid


-------------
add procfs support. 
    basically need to add another type of file. 
    it cannot be device file, which does not keep track of offset.
    the read/write path also must be implemented. 

added dev/ support, esp fb and fbctl (for set parameters, control, etc)

an intersting bug... write to /dev/fb didn't flush completely. artifacts on display. 
can be a good example. 

cf devfb_write()

xv6 fs filesize limit... 260KB. too limited. need to swtich to fat32 soon. 

added test for pipe3: two writers, one reader. 
    needed by liteNES event queue (has to receive on both timer and input events)
    (we dont have threads, or nonblocking IO support. can use pipes to implement)

-------------

[ ] add hw suport for  rpi3 
    [ ]  refactor display driver  -- clean up the code, make fb interface (w/ double buffering                
    
    [x]     add kb driver (usb seems more universal - both storage and input)

[x] ported slider 
[x] port litenes + mario. fixed the bug of not being able to handle x=-1 drawing
    cf: nes_flush_buf()

[x] implemented fb flip for nes (mario)

    [x]     add storage driver
    [x]         usb storage r/w -- existing code no irq (otherwise FSM becomes messy)
                    ref: the C  version of circle usb stack
                input driver is irq driven 
    [ x] sd card driver    
    [ ]  port doom 

    ~~~add fat32 support
        useful: https://cpl.li/posts/2019-03-12-mbrfat/

[ ]  add support for rpi3 hardware
    [x]     sound driver
    rf: pwm (cpu or dma playback, via 3.5mm jack
    
    https://github.com/babbleberry/rpi4-osdev/tree/master/part9-sound
    has example on how ot play .wav file

    https://github.com/PeterLemon/RaspberryPi/tree/master/Sound/PWM/8BIT/48000Hz
    
    ref: via HDMI (seem to use DMA, not via firmware
        https://github.com/rsta2/circle/tree/master/sample/29-miniorgan
        https://github.com/rsta2/circle/blob/master/sample/29-miniorgan/miniorgan.cpp
        https://github.com/rsta2/circle/tree/master/lib/sound

        ported from  circle (older veersion of circle? use vchiq firmware
        (too bloaty ... tried but decided to go the DMA/PMW route first 
        https://github.com/ayuusweetfish/AMPi

        contains code for ogg decoding (via stb_vorbis)
        https://github.com/ayuusweetfish/AMPi/tree/master/sample


        can via VCHQI
        https://forums.raspberrypi.com/viewtopic.php?t=306441

        Apr 2024. tried and fixed some problems (e.g. arm32 insns in coroutines)
    there likely to be more (e.g. assumption of identity va mapiping) but expected
    to be fixable. 

    the nice thing -- playback via hdmi 

    the probmem; it is very much bloated. talking to a propritary firmwre just for
    sound playback seems an overkill that most studenrts wont care to undrestand. 
    it is also not a mainstream approach 

    by comparison, using pwm to playback on 3.5mm jack is a much simpler, cleaner, 
    and esier to understand solution. 

    so gave up as of now. in favor of pwm. 
    

    thoughts: glue circle? or port it manually in c?

        this is an attempt to carva out a minm part of circle, so that we can run sound 
    pwm. the plan was to compile the cirlce (in c++) and glue with the rest of the 
    kernel. 

    this minimizes changes to circle (it has mutiple classes, subclasses in the 
    suond subsystem..., which can be painful to converet to c). the downside would be:
    the glue is ugly, and linking c++ to c makes hte kernel bloated. it also 
    limits further cusotimization of that part. 

    eventually, I decided to manually port the circle's pwm sound code (as c), which 
    turns out to be successful. 

    this code base is therefore left for future ref. 

    xzl, Apr 2024


[x] ktimer introduced a problem (in irq handler, callback out of holding spinlocks), which corrupted kernel memory randomly. why? couldnt' fig out
foudn the problem via going back to github commits. 
otherwise difficult to imagine!! 

reverted to old ktimer code 
polished procfs code

[x] a good bug      cf sound.c test_sound(); 
test_sound() busy waits for sound playback to finish (driven by irqs)
it works when it is called from kernel's process(), but 
hangs (no irq whatsoever) when called from procfs's write() 
function. 
the reason is --- 
// busy wait, may not work in syscall conext, as we may be holding spinlocks e.g. ftable's spinlock which turned off irq already....
FIX: comemnt out the busy wait, just return from write() syscall, let the kernel play....
 
[x] a good bug
when porting code from cpp, new[] forgot to take intou accoutn the elment size (u32). 
hence dma buf is 4x smaller than should be. when init dma transfer (with the right length), 
only the 1st irq hits (wihtout any channel irq status set -- why???). then status 
reg shows DMA xfer 'ends'. (prematurely?) 

indeed weird behavior. but after allocating the right size, things work 

[x] fix a bug that exists in the copied code (bigger xv6 files)
    the erronoeous use of idx (the orginal authors didnt test thorougly

more: now hit the ramkdisk capaicty --- panic. why???? 

good dma article on rpi3
https://iosoft.blog/2020/05/25/raspberry-pi-dma-programming/

[x] extend xv6 filesystem. which has limited file size. 
its a well known exercise. 
https://github.com/himelbrand/xv6-fs/commit/c80d7d8e5101b8faef745a58611a3bd15113b4fe (has bug
https://github.com/nxbyte/Advanced-xv6/blob/master/6%20-%20Filesystem%20-%20Triply%20Indirect/fs.c (btter, also has a small bug)
    ^^ also contains impl for triple indirect ptrs


fixed some bugs from public code. also fixed issues in usertests

in the future, cmdline flash to sd card: 
C:\Program Files (x86)\Raspberry Pi Imager>rpi-imager-cli.cmd
Usage: --cli [--disable-verify] [--sha256 <expected hash> [--cache-file <cache file>]] [--first-run-script <script>] [--debug] [--quiet] <image file to write> <destination drive device>

considered fat32 solution (opensource, elmfs or called ChaN fat32), used by 
rtthread OS and Circle. it's mature but complex (6ksloc). it's also very self contained, 
exposing high level, syscall-like interface. no inode concept. any on-disk data 
structures are encapsulated and not exposed. 
not amenable to port to xv6's internal inode-centric fs design (and block layer). 

therefore, decide to go with xv6's fs... and put it on the 2nd partition of micro sd card??

extended xv6 filesize limit (both kernel and mkfs) with doubly indirect pointers. 
doubly indirect in itrunc - TBD. 

also mkfs.c balloc() can only handle on bitmap block at most. 
    fine if block size is lareg (1024) and few loaded files. 
    but fail with smaller block size (512) and more loaded files...
[x]    so improved balloc() 

the problem is: xv6 fs lacks of inter operatibility. 

how to put xv6 fs on a sd card? 
    we may flash fs img to teh 2nd partition of sd card (1st partition is fat32 needed for boot)
    however it requires windows/macos programs that accesses raw sd card, 
    parses MBR and does the writing....

    or, we creaet a large img with multipelt parittions. then flash the whole img 
    to sd card (using pi imager, eg)
    however it is non trivial to create an sd card image from cmd line, that can boot rpi3. 
    (has some reqwuirement on mbr record, partition size (?) etc )
    it can be done. just take time.     
    also, flash the whole sd card every time ... to update kernel or any user program 
    is tedous...

try a new approach: have fat32 as a secondary fs within xv6 
    xv6 fs ... for rootfs (ramdisk, core programs 
    sd card ... for large data, programs, music, etc. 

[x] ported sd driver from "baremetal tutorial". polling, no irq driven. 
read/write one block takes ~1ms

[x] fix usb driver bug that caues qemu boot very slow
apr 26 2024, fixed. 
problem still in 
    DWHCIFrameSchedulerNoSplitWaitForFrame()
	// xzl: below - tried to wait for the next frame 
	// however, on qemu, the assumption that cpu runs much faster than io is broken. 
	// cpu won't read continuous frame numbers. 
	// given that DWHCI_MAX_FRAME_NUMBER is 3fff, there is also a chance to wrap around (?)
    pThis->m_nNextFrame = (DWHCI_HOST_FRM_NUM_NUMBER (DWHCIRegisterRead (&FrameNumber))+1) & DWHCI_MAX_FRAME_NUMBER;
    the original code uses a busy loop to expect FrameNumber to go to m_nNextFrame. 
        this breaks on qemu. ^^ cf above. 
    // CHANGED TO BELOW .... 
    while ((DWHCI_HOST_FRM_NUM_NUMBER (DWHCIRegisterRead (&FrameNumber)) & DWHCI_MAX_FRAME_NUMBER) == cur_frame)
			; // do nothing	
    // SEEMS FINE WITH QEMU (keep the orginal code for rpi3 hw	


[ ] overhaul makefile system 
    PLAT=xxx has some bugs. sometimes not effective?? (fixed)
    have a build dir, then separate dir for PLAT=virt PLAT=rpi3 etc. also different binary file names

[ ] network, tcpip
https://github.com/babbleberry/rpi4-osdev/tree/master/part15-tcpip-webserver


------------
rpi3 framebuffer animation idea (double buffer, vsync, etc
https://www.valvers.com/open-software/raspberry-pi/bare-metal-programming-in-c-part-5/#part-5armc-016


------------
NJU OS website 
https://nju-projectn.github.io/ics-pa-gitbook/ics2024/



newlib nju os
https://github.com/NJU-ProjectN/newlib-navy/tree/master

mynes: 
this seems more suitable -- 
https://github.com/NJU-ProjectN/LiteNES

NJU os port
https://github.com/NJU-ProjectN/am-kernels/tree/master/kernels/litenes/src
original
https://github.com/yaglo/mynes

a full fledge nes emulator (still active project
https://github.com/TASEmulators/fceux


-------------
sdl, minisdl 
cf; NJU OS
https://github.com/NJU-ProjectN/navy-apps/tree/master/libs

https://github.com/NJU-ProjectN/navy-apps/tree/master/libs/libminiSDL/src

consider its sound interface. ...
https://github.com/NJU-ProjectN/navy-apps/blob/master/libs/libminiSDL/src/audio.c

about mixer SDL_mixer
https://nju-projectn.github.io/ics-pa-gitbook/ics2024/4.5.html#%E5%AE%9E%E7%8E%B0%E6%B7%B7%E5%A3%B0%E5%BA%93sdlmixer
shoudl go with the orignal implemntation (instewad of roll it own)
but it's quite complex (warranted) though

SDL official code 
https://github.com/libsdl-org/SDL/tree/SDL2/src/audio
what's nice about SDL -- it has various in-house impl of c data structures and utlities
it is also ported to various platforms (ps2, psp, etc....
the modification seems rather small 


but it also expects multithreading... e.g. SDL audio relies on callback (which is called
from a thread 
cf https://github.com/libsdl-org/SDL/blob/main/src/thread/SDL_thread.c#L317
threading is platform specific (e.g. for PS vita, goes to sce devkit's thread considerationhttps://github.com/libsdl-org/SDL/blob/ec97857a87dd195b6c84d35a2f347a4772f4aaaa/src/thread/vita/SDL_systhread.c#L72

so unless we change SDL interface dramatically, threading seems natural and must 
be supported by kernel (in addition to fork() 

------------------
threading idea, clone() 

without threading, multitask programs can only use fork() and pipe() to communicate...
essentially becomes message passing ... 

 long clone(unsigned long flags, void *stack,
                     int *parent_tid, unsigned long tls,
                     int *child_tid);

In Linux 2.4 and earlier, clone() does not take arguments
       parent_tid, tls, and child_tid.

CLONE_SETTLS        
tls -- The TLS (Thread Local Storage) descriptor is set to tls.

for now, only supprot 
CLONE_VM 

https://man7.org/linux/man-pages/man2/clone.2.html


NB: newlib has no pthread (very old version had)
glibc has pthread impl
https://sourceware.org/git/?p=glibc.git;a=tree;f=nptl;h=d0ce23d37e9b77d6ff82ffdee0f7a1f8f137aa41;hb=HEAD

musl also has pthread
https://git.musl-libc.org/cgit/musl/tree/src/thread


clone() works. a few things
- there must be a user wrapper (like musl clone.s). when child task returns to userspace, it shall not use the parent stack nor resume from the callsite of clone (unlike fork) ... will cause problems 

- the thread stack... does not have to be a static array. instead, can be a VA in the middle of user VM (unmapped). then rely on the damdn paging to alloc stack page

--------------------
DEBUG SUPPORT 

GDB bring up? 
it woudl be very useful. 
however, the engineering effort seems high... GDB is pat of binuntils and relies on 
things like BFD, textinfo, readline.... 

can we debug user app using qemu+gdb? maybe feasible? 
    if so would help a lot 

    CAN BE DONE. it's the same idea. e.g. 
    instewd of "gdb-multiarch kernel/build/kernel8.elf", do: 

    gdb-multiarch usr/LiteNES/nes
    (then can set breakpoint, single step, etc)


    after some trial, print local variables seem get confused by virtual addr? 
        like multiple programs will have the same virt addr? 
    maybe solved by linking the target program to a diffent virt addr base     

backtrace upon crash? 
backtrace print already in libc
can be implemented as follows ---- 
    + a bit more signal support (other than kill), with userspace handlers 
    do_mem_abort() will send signal (pending), return to userspace, and cause 
        signal handler to exec there. therefore backtrace dump. 

--------------------
ogg decoder

stb -  vorbis ogg decoder
I dont undersatnd why it's .h and.c packed in a file, and you have to extract .h out??
https://github.com/nothings/stb/tree/master
can simply use navy version (splitted)
https://github.com/NJU-ProjectN/navy-apps/blob/master/libs/libvorbis/src/stb_vorbis.c

Ogg Vorbis is a fully open, non-proprietary, patent-and-royalty-free, general-purpose compressed audio format for mid to high quality (8kHz-48.0kHz, 16+ bit, polyphonic) audio and music at fixed and variable bitrates from 16 to 128 kbps/channel.


--------------------

^^ in fact, doom has SDL port (simple, clean). so having SDL is good for doom port
    also doom can be used to test SDL sound...
also PAL.... 

-------------
sdlpal
https://github.com/NJU-ProjectN/pal-navy/tree/master
the navy's version is simpler than upstream (too much platforms supoted?

navy desc for pal
https://nju-projectn.github.io/ics-pa-gitbook/ics2024/3.5.html#pal-%E4%BB%99%E5%89%91%E5%A5%87%E4%BE%A0%E4%BC%A0


about the cpp lib in sdlpal... (there's workaround
https://nju-projectn.github.io/ics-pa-gitbook/ics2024/3.5.html#pal-%E5%B8%A6%E9%9F%B3%E4%B9%90%E5%92%8C%E9%9F%B3%E6%95%88




-------------
device interfacwes

nju /dev/ ingtetfaces
https://github.com/NJU-ProjectN/navy-apps/blob/master/libs/libos/src/native.cpp

sdl2 kb event interfaces
https://wiki.libsdl.org/SDL2/SDL_Keysym


three major interfaces
framebuffer, keyboard, sound
https://github.com/NJU-ProjectN/navy-apps/blob/master/libs/libos/src/native.cpp#L167
https://github.com/NJU-ProjectN/abstract-machine/blob/master/am/include/amdev.h


in NJU OS, kb events -- 
    dev read/write return as textual strings. 
    (ease of debugging
    https://github.com/NJU-ProjectN/navy-apps/blob/master/libs/libos/src/native.cpp#L207
    )

also cf
https://github.com/NJU-ProjectN/navy-apps/blob/master/README.md


-------------
procfs interfaces
NJUOS
https://github.com/NJU-ProjectN/navy-apps/blob/master/README.md
cf:
https://github.com/NJU-ProjectN/navy-apps/blob/master/libs/libos/src/native.cpp#L207

-------------
sd card driver

rpi3 baremetal tutorial, sd read/write. busy wait for read/write
(often the code style is good....
https://github.com/bztsrc/raspi3-tutorial/blob/master/15_writesector/sd.c


rtthread. code also clean. still, busy wait for read/write
https://github.com/RT-Thread/rt-thread/blob/master/bsp/raspberry-pi/raspi3-64/driver/drv_sdio.c


from nctuos. simple. but busy waiting, no irq
https://github.com/GrassLab/osdi/blob/master/supplement/sdhost.c




https://grasslab.github.io/osdi/zh_TW/labs/lab8.html

-------------
stack unwind ref:
https://elixir.bootlin.com/linux/latest/source/arch/arm64/kernel/stacktrace.c
libunwind ... too heavy 
rt-thread os... no unwind for armv8, only v7
circle ... no unwind, only gdb stub support 

---------------

source files replaced

include/mm.h
src/linker-qemu.d

src/mini_uart.c (removed)

added
src/pl011.c


------
qemu hw emulated for rpi3
https://www.qemu.org/docs/master/system/arm/raspi.html
(systimer -- no irq still??





~~~~~~~~~~~~~~~~~ 
fat32 consideration

filename format: 
http://elm-chan.org/fsw/ff/doc/filename.html


readi/writei wont be changed for fat32, which has its own impl 

how about dir? also give it an inode...(as it can be opened for long)

BSIZE ... isnt' is easier 1024 --> 512???
    (sd card is 512, ramdisk 512, ...
    used to be a limiter of filesize w/o lv2 indirect links, but 
    w/ it, we should be fine???

[x] sys_open()


[x] fileclose()

[x] fileread .. to check
[ ] filewrite 


bio interface. 
    bwrite() never exposed to fs.c b/c the idoim for inode writei is: 
        bread() lock & read buf, then mod buf, then log_write() which writes bwrite, then rls
    
    but since we are doing raw sect acess, we need to bget then bwrite

^^ coiuld be good exercise for porting FAT fs...

FRESULT f_stat (const TCHAR* path, FILINFO* fno);		
unlijke stat() which takes a fd (already has file* and inode), and calls filestat() to relaize locking ...then stati()

this fat's stat takes a path. to ensure locking (b/c our lock is at inode level), 
the right impl seems to opoen() the path, has file and inode, then 
call f_stat internally.... 

TBD
[x] ls readdir cannot stop by itself??? -- fixed. bug. 
[x] impl seek() on fat files

~~~~~~~~~~~~~~~~~ 
sdl sdl_keycode issues. 
cf: SDL_default_keymap

// xzl: NB: in table below, two differnet scancodes may have same SDL_keycode. (weird)
// ex: all zeros, and SDLK_EQUALS & SDLK_F4. why so? 
// however enum SDL_KeyCode (sdl-keycode.h) differentiate them using bit 30
// cf SDLK_SCANCODE_MASK. 
// the problem is that SDL_GetKeyFromScancode() still returns
// "raw" codes in the table below. 

solution: get rid of all code and customzie SDL_GetKeyFromScancode....
also clean up other keyboard.c code... 

~~~~~~~~~~~~~~~~~ 
doom epxects ctrl/alt keyup/down events. 
but ctrl/alt/shift... are passed as keyevents modifiers (usb kb event specs)
directly from usb hw. cf kb_intr() 
so our kb events from kb.c do not include evnrts for mod keys

although there's scancode def for ctrl/alt/etc, the usb keyboard will return things like
(left alt key pressed)
// from kernel
kb.c:115 mod 4 key 00 00 00 00 00 00

future work (project idea): kb_intr can be modified to detect these events... 

as of now just modify doom code...to use other keys
~~~~~~~~~~~~~~~~~ 
a bug caused by linker/compiler issue

nes breaks when switching to gcc9.4 (ubuntu 2004) to gcc9.5(ubuntu 2204)
symptom: blank/gray screen (only background), no response

cause: 
cpu_run will do this
        if (cpu_op_address_mode[op_code] == NULL) {
        }
however,       
    void cpu_address_implied() was linked at addr 0. 
    (b/c user.ld starts .text from addr 0). 
therefore, cpu_run() skips many isns it shouldn't skip. 
gcc9.4 didnt have this issue, even though it links another func at addr 0; 
but no func pointer was taken for that func. 

this is figured out by comparing the "good" nes and the "bad" nes, 
and compare their cpu insns traces side by side
(after noticing that PPU.mask was not programmed at all, and iowrtie was not called regularly)

fix: create a linker script (nes.ld) which starts text from 1000

long term: need to port gdb?? 

~~~~~~~~~~~~~~~~~ 
creawte disk image, partitions
https://unix.stackexchange.com/questions/771277/creating-disk-image-with-msdos-partition-table-and-fat32

# use parted to create patitions
# 128MB
# dd if=/dev/zero of=smallfat.bin bs=1M count=128
# or: 
# truncate -s 128MB smallfat.bin

    # 1 part
    parted smallfat.bin \
    mklabel msdos   \
    mkpart primary fat32 4096s 100%

    # 2 parts
    parted smallfat.bin \
    mklabel msdos   \
    mkpart primary fat32 4096s 50% \
    mkpart primary fat32 50% 100%

# WARNING: You are not superuser.  Watch out for permissions.
# ^^ this is ok

# check partitions
parted smallfat.bin print
# or
mmls smallfat.bin

# mkfat32 for partition 1 (note ~/.mtoolsrc must be configured)
# -F for fat32, default fat16
mformat -F -i smallfat.bin x:

# list dirs 
mdir -i smallfat.bin  x:

# mkdir 
mmd -i smallfat.bin ::/testdir

~~~~~~~~~~~~~~~~~  
mmls 
list partitions of an image. useful

xl6yq@granger1 (next)[exp9]$ mmls smallfat.bin
DOS Partition Table
Offset Sector: 0
Units are in 512-byte sectors

      Slot      Start        End          Length       Description
000:  Meta      0000000000   0000000000   0000000001   Primary Table (#0)
001:  -------   0000000000   0000002047   0000002048   Unallocated
002:  000:000   0000002048   0000004095   0000002048   Linux (0x83)
003:  -------   0000004096   0000004176   0000000081   Unallocated
004:  000:001   0000004177   0000008191   0000004015   Linux (0x83)

Another Ex:

xl6yq@granger1 (next)[exp9]$ mmls smallfat.bin
DOS Partition Table
Offset Sector: 0
Units are in 512-byte sectors

      Slot      Start        End          Length       Description
000:  Meta      0000000000   0000000000   0000000001   Primary Table (#0)
001:  -------   0000000000   0000004095   0000004096   Unallocated
002:  000:000   0000004096   0000262143   0000258048   Win95 FAT32 (0x0c)


~~~~~~~~~~~~~~~~~


fat32 mtool
https://wiki.osdev.org/MTools

NB: "::" SEEMS NOT WORKING FOR MTOOLS THAT COME WITH UBUNTU 

has to specify ~/.mtoolsrc
mtools_skip_check=1
drive x: file="/u/xl6yq/p1-kernel-next/src/exp9/smallfat.bin" exclusive partition=1

then: 
xl6yq@granger1 (next)[exp9]$ mdir -i smallfat.bin x:
 Volume in drive X has no label
 Volume Serial Number is 145D-9448
Directory for X:/

SMALL             2000 2024-01-01   0:00
        1 file                2 000 bytes
                          1 026 048 bytes free

also can do:
mcopy -i smallfat.bin x:/SMALL /tmp/

https://unix.stackexchange.com/questions/629492/create-and-populate-fat32-filesystem-without-mounting-it
# Create a 2 MB file
dd if=/dev/zero of=disk.img bs=1M count=2

# Put a FAT filesystem on it (use -F for FAT32, otherwise it's automatic)
# NB: this wont create partition
mformat -i disk.img ::

# Add a file to it
mcopy -i disk.img example.txt ::

# List files
mdir -i disk.img ::

# Extract a file
mcopy -i disk.img ::/example.txt extracted.txt


support for mutiple partitions... seem bad???

like, mformat has problems with formating partition2...
"Not enough sectors"


~~~~~~~~~~~~~~~~~ 

usertests for fat32

after implementing chdir() and relative path, no longer need
dedicate functions, e.g. dirtestfat()
just do: 
    cd /d/
    /usertests dirtest 
this should perform file tests on fatfs


~~~~~~~~~~~~~~~~~ 

qemu's virtual fat filesystem (vvfat)
"Virtual FAT disk images"
https://www.qemu.org/docs/master/system/qemu-block-drivers.html

can be usefl 
    QEMU=/u/xl6yq/teaching/p1-kernel-workspace/qemu-8.2-apr2024/build/qemu-system-aarch64
    .img -serial null -serial mon:stdio \
    -d int -D qemu.log \
    -nographic \
    -drive file=fat:rw:/tmp/testdir,if=sd,format=rawxl6yq@granger1 (next)[exp9]$ ${QEMU} -M raspi3b \
    > -kernel ./kernel8.img -serial null -serial mon:stdio \
    > -d int -D qemu.log \
    > -nographic \
    > -drive file=fat:rw:/tmp/testdir,if=sd,format=raw

but SD card driver seems expect certain disk size
    qemu-system-aarch64: Invalid SD card size: 504 MiB
    SD card size has to be a power of 2, e.g. 512 MiB.
    You can resize disk images with 'qemu-img resize <imagefile> <new-size>'
    (note that this will lose data if you make the image smaller than it currently is).
searched online, no doc on how to specify disk size for vvfat....
(give up as of now...)




~~~~~~~~~~~~~~~~~ 

sd card emmc boot log

EMMC: GPIO set up
EMMC: reset OK
sd_clk divisor 0x68, shift 0x6
EMMC: Sending command 0x0 arg 0x0
EMMC: Sending command 0x8020000 arg 0x1aa
EMMC: Sending command 0x37000000 arg 0x0
EMMC: Sending command 0x29020000 arg 0x51ff8000
EMMC: CMD_SEND_OP_COND returned VOLTAGE 0x00xf98000
EMMC: Sending command 0x37000000 arg 0x0
EMMC: Sending command 0x29020000 arg 0x51ff8000
EMMC: CMD_SEND_OP_COND returned COMPLETE VOLTAGE CCS 0xffffffff0xc1f98000
EMMC: Sending command 0x2010000 arg 0x0
EMMC: Sending command 0x3020000 arg 0x0
EMMC: CMD_SEND_REL_ADDR returned 0x00x50480000
sd_clk divisor 0x2, shift 0x0
EMMC: Sending command 0x7030000 arg 0x50480000
EMMC: Sending command 0x37020000 arg 0x50480000
EMMC: Sending command 0x33220010 arg 0x0
EMMC: Sending command 0x37020000 arg 0x50480000
EMMC: Sending command 0x6020000 arg 0x50480002
EMMC: supports SET_BLKCNT CCS
sd_readblock lba 0x0 num 0x1


~~~~~~
libc, newlib        (choice of Zehyper, realtime OS...
office manual
https://sourceware.org/newlib/libc.html

https://github.com/bminor/newlib/tree/master/newlib/libc
modules:
argz (arg parsing? 
ctype (type handling, char, int, etc. 
errorno
iconv (conversion of encoding?
locale (no need?
machine (arch specifc code, e.g. optimzed memcpy etc. MUCH needed
    https://github.com/bminor/newlib/tree/master/newlib/libc/machine/aarch64

stdio (needed
stdio64             Large File Input and Output   (not needed
posix "several utility functions specified by POSIX, but not by C.     mot needed???

reent   reentran versyions of variouss fucntions.. used for multithread cases? (which we dont have??
search      various search algo, hash etc .. can be compioled with ease
ssp         ... statck smath protection
stdlib       need
string      need
sys         old libgloss?? there's arm, but no aarch64
syscalls
time
unix        ... needed?? (things like basename, getcwd, ...
xdr     "eXternal Data Representation (XDR) code from SunRPC" 

signals??   ... use emulation?? (no kernel support
c++ runtime support? 
https://wiki.osdev.org/C%2B%2B

also cf rt-thread
https://github.com/NJU-ProjectN/rt-thread-am/tree/a5810addff690d4b12bc8c65598b128f7f062f23/components/libc/cplusplus



setjmp???


the github mirror
https://github.com/bminor/newlib

structure (newlib vs libgloss
https://www.embecosm.com/appnotes/ean9/html/ch03s01.html
The main newlib directory contains the bulk of the code for the two main libraries, libc and libm, together with any architecture specific code for particular targets


libgloss for aarch64
https://github.com/bminor/newlib/tree/master/libgloss/aarch64
https://github.com/bminor/newlib/tree/master/newlib/libc


porting newlib
https://wiki.osdev.org/Porting_Newlib
mostly how to build, how to configure, define syscalls, etc.

NJU ported newlib
https://github.com/NJU-ProjectN/newlib-navy/tree/master
based on an older vesion of enwlib.. its pretty much libc ONLY, no libm etc



                ARCHITECTURE-VENDOR-OS

            For example, you can use the alias `sun4' as a HOST argument or in a
            `--target=TARGET' option.  The equivalent full name is
            `sparc-sun-sunos4'.

./configure --target=aarch64-linux-gnu CC='aarch64-linux-gnu-gcc-9'


# cf newlib/README Compiling NEWLIB
# this is right
CC='aarch64-linux-gnu-gcc-9' ../newlib/configure --host=aarch64-linux-gnu \
    --disable-multilib \
    --disable-newlib-iconv

# libgloss

CFLAGS=-I'../newlib/libc/include' CC='aarch64-linux-gnu-gcc-9' ../libgloss/configure --host=aarch64-linux-gnu



make -j10

mkdir build
~~~~ ~~~~ ~~~~ 
newlib configure system... 

loolisk like it just check all subdirs... ??

 if test x${unix_dir} != x; then
  HAVE_UNIX_DIR_TRUE=
  HAVE_UNIX_DIR_FALSE='#'
else
  HAVE_UNIX_DIR_TRUE='#'
  HAVE_UNIX_DIR_FALSE=
fi

then in Makefile.in...
@HAVE_UNIX_DIR_TRUE@am__append_25 = \
@HAVE_UNIX_DIR_TRUE@	libc/unix/getcwd.c \
@HAVE_UNIX_DIR_TRUE@	libc/unix/pread.c \
@HAVE_UNIX_DIR_TRUE@	libc/unix/pwrite.c \
@HAVE_UNIX_DIR_TRUE@	libc/unix/sigset.c

xdr_dir-->this controls whether a dir is built or not 

"xdr is compiled and supported only for those platforms which
set xdr_dir nonempty in configure.host. At present, the list
of platforms which do this is:
   cygwin"

# source 
configure.host: 
    for each "host" or "target", defines which "dir" should be built or not (e.g. unix, posix, etc

    here, based on "host" (triplet), it will decide what to compile, and what not to compile 


# generated 
config.log config.status
can see the specific var values, e.g. "host_cpu"

~~~~ ~~~~ ~~~~ ~~~~ ~~~~ ~~~~ 



~~~~ 
altenrative libc is musl
https://www.musl-libc.org/how.html
https://git.musl-libc.org/cgit/musl/tree
seems simpler than newlib???

CC='aarch64-linux-gnu-gcc-9' \
CFLAGS=-mcpu=cortex-a53+fp+simd \
./configure --target=aarch64-linux-gnu \
--prefix=/home/xzl/musl

it's much tightly coupled with linux (?), e.g. expecting all syscalls (and numbers)

cf: obj/include/bits/syscall.h
arch/aarch64/bits/syscall.h.in ....
in the lib, all syscalls are made in this fashion
 int r = __syscall(SYS_readlink, path, buf, bufsize);
^^ if wanted to port, all these callsites shall be changed 
(or the kernel's syscall interface shallbe consistent with Linux...0

NOT QUITE 'EMBEDDED' AS NEWLIB...

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
new task_struct mm design

use things like inode table. .. a fixed number of slots.
in this way, task_struct::state have a flag, indicating if the slot is in use. 
    with task_struct::lock, this results in a simple design. 

this avoid the race condition from dynamically allocating & freeing task_struct. 
    once free()d,  nothing prevents the memory for task_struct from being reused by other kernel d/s therefore even unlocking becomes unsafe (may corrupt other kernel d/s)

    the same rpblem applies to mm struct. 

    one workdaround is to lock the mm allocator in the midst of freeing task_struct & mm_struct (i.e. pausing mem alloc). its possible, but seem overly complex (esp has to take care of freeing both task_struct and mm).

    so a static array with fixed # of slots could do. 
    each task_struct: 4KB, with MAX_NR_TASKS=128, that's only 512KB
    mm_struct is around 1KB each (does not even need a whole page). so x128 is 128KB. 
    NOT BAD


fixed a bug: sched.c
previousl, each kernel stack is a page, dynamically allocated. so it's nautrally page
algined. 
now we define them as static var, (by default) they are no longer aligned (depends
on compiler's chance). this breaks things, e.g. ret_from_fork asm, which uses the 
alignmenta assumption to get task-task_struct. and it is not tough to figure out. 

solution: force aligned at thread_size, and add dynamic check BUG() in code. 
// kernel_stacks[i]: kernel stack for task with pid=i. 
// WARNING: various kernel code assumes each kernel stack is page-aligned. 
// cf. ret_from_syscall (entry.S). if you modify the d/s below, keep that in mind. 
static char kernel_stacks[NR_TASKS][THREAD_SIZE] __attribute__ ((aligned (THREAD_SIZE))); 

now mario can run 
~~~~~~~~~~~~~~~~~~~~~~~

fixed a nasty bug ... 
old memcpy() in util.S copy multiply of 8 bytes (!!) which silently corrrupt mem... and 
casues -O2 kernel to fail to set user VM>.....

rename old memcpy (and memzero, which is a latent bug) with _aligned. 
default ones have no alignment requimrenets. 
and change all call sites. 

~~~~~~~~~~~~~~~~~~~~~~~
fix a bug: when mm_struct slot reused, user_page_count must be reset to 0. 
otherwise it just keeps growing

~~~~~~~~~~~~~~~~~~~~~~~~~~~
FL notes on cpp compilation findings. 
env: aarch64-linux-gnu-gcc-9 aarch64-linux-gnu-g++-9 (9.5.0)

compiler flags: both gcc and g++;  both compilation and link
"-nostdlib -nostdinc -nostartfiles -ffreestanding"

gcc/g++ won't supply crt0/i/n.o (which defines _main()). therefore must provide by us

gcc wont need crti.o crtn.o (which defines & calls ctor dtor etc). 
    it needs crt0.o which defines _main(). no _init() _fini() needed

g++ need crt0.o crti.o crtn.o. 
    for cpp: we need to provide ctr0.o which defines _main(); call _init()/_fini() before _main()
    default linker script is ok. (init_array/fini_array will be populated by linker for us)
    
notes on ctor/dtor "priorties (cf usercpp.ld)     
    /* xzl: these are suggested by https://wiki.osdev.org/Calling_Global_Constructors
    for ctor/dtor "priorties". however, if crtX.o are passed to g++ as, e.g. MYPATH/crtX.o, 
    the linker will get confused, linking the same objs twice; hence redefined symbols error. 

    the best solution is avoid the following (hence not sorting ctors) as long as "priorities"
    are not required. if they are required, maybe change the following using the same paths of 
    crtX.o passed to g++ */

    /* Include the list of initialization functions sorted. */
    .init_array :
    {
        crti.o(.init_array)
        KEEP (*(SORT(EXCLUDE_FILE(crti.o crtn.o) .init_array.*)))
        KEEP (*(EXCLUDE_FILE(crti.o crtn.o) .init_array))
        crtn.o(.init_array)
    }
    ......
        

# tehse are built in ctr*. their _init _fini wont call ctro dtor...
# CRTI=/usr/lib/gcc-cross/aarch64-linux-gnu/9/../../../../aarch64-linux-gnu/lib/../lib/crti.o
# CRTN=/usr/lib/gcc-cross/aarch64-linux-gnu/9/../../../../aarch64-linux-gnu/lib/../lib/crtn.o


~~~~~~~~~~~~~~~~~~~~~~~~~~
demo idea

Raspberry Pi 400 ... ideal. but based on pi4 compute module (hence no rpi3 support

gamehat for rpi3
https://www.amazon.com/Waveshare-Game-HAT-Resolution-Experience/dp/B07G57BC3R
++ has display, speaker (!)
++ battery 
-- no keyboard, gamepad needs extra driver


SmartiPi Touch 2 - Case for The Official Raspberry Pi 7" Touchscreen Display - with Cooling Fan
.. display only, still no kb 

additoinal usb kb cheap?? (kidna everywhere

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
litenes nes project idea
// xzl: TODO: support graceful exit. can be a project idea
    // for a special key press (e.g. 'q'), returns from this func and goes 
    // back to fce_run which further exits the program
    // but before that, need to tell the timer task & event task to quit too; 
    // has to wait() them to quit.     


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[ ] multicore
https://github.com/babbleberry/rpi4-osdev/tree/master/part10-multicore
https://github.com/bztsrc/raspi3-tutorial/tree/master/02_multicorec

core1+ wont run automatically... until core0 writes to 0xe0... (PA).. see links above

at boot.S
// core1+ has to wait a bit, until core0 populates kernel pgtables shared
	// by all cores. 
	// - how about core0 "releases" core1+, after populating pgtables & turning on MMU? wont work
	//		for whatever reason, writing to VA cannot release core1+
	// - how about core0 "releases" core1+, after populating pgtables, before turning on MMU?
	//		core1+ still has to wait a bit. otherwise they seem to hang (using invalid pgtables?

https://github.com/LdB-ECM/Raspberry-Pi/tree/master/Multicore
provided diskimg does not work??


rpi firmware arm8stu
https://leiradel.github.io/2019/01/20/Raspberry-Pi-Stubs.html
https://andrei.gherzan.ro/linux/raspbian-rpi4-64/#:~:text=The%20armstub%20is%20the%20code,CPU%20before%20running%20the%20kernel.

https://github.com/raspberrypi/tools/blob/master/armstubs/armstub8.S

the code is executed as firmware (by gpu?) after loading the kernel, before executing the kernel 
